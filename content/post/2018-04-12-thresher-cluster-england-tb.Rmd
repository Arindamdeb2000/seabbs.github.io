---
title: "Validating Clusters in Tuberculosis Monitoring Indicators - using Thresher"
author: 'null'
date: '2018-04-12'
description: "Using fingertipsR, principal component analysis, and partitioning around medoids to identify clusters of counties based on Tuberculosis monitoring indicators"
slug: thresh-cluster-england-tb
draft: yes
tags: ["data analysis", "data visualisation", "rstats", "TB", "PHE", "infectious disease", "clustering", "thresher"]
categories: ["R"]
twitterImg: "img/fingertips/storyboard-fingertips-tb-clust.png"
---

```{r knitr-opts, echo = FALSE}
knitr::opts_chunk$set(cache = TRUE, dpi = 330, 
                      fig.height = 8, fig.width = 8,
                      warning = FALSE)
```

## Introduction

- Previous post using `fingertipsR` to extract Tuberculosis monitoring indicators for England
- Used PCA and PAM clustering to determine the optimal number of clusters in the data and then compared these clusters
- This post using new package Thresher, explore package functionality, compare results to previous findings
- What is the impact of excluding Incidence rates from the analysis?

## Packages

The first step is to load the packages required for the analysis, we do this using the fantastic `pacman` package.

```{r get-packages, message = FALSE}
if (!require(pacman)) install.packages("pacman"); library(pacman)
p_load("gpclib")
p_load("rgdal")
p_load("raster")
p_load("maptools")
p_load("tidyverse")
p_load("purrr")
p_load("Thresher")
p_load("NbClust")
p_load("fingertipsR")
p_load("viridis")
p_load("ggthemes")
p_load_gh("thomasp85/patchwork", dependencies = TRUE)
```

## Data

```{r get-prev-post-data}
tb_monitoring_indicators <- readRDS("../../static/data/fingertips/tb-pam-clusters.rds")

tb_monitoring_indicators
```

## Analysis


```{r perform-dim-reduction}
threshed <-tb_monitoring_indicators %>% 
  dplyr::select(-cluster) %>% 
  dplyr::select_if(is.numeric) %>% 
  as.matrix %>% 
  Thresher
```

```{r outlier removal and clustering}
reaped <- Reaper(threshed, 
                 useLoadings = TRUE)
```

```{r noise-features}
colnames(tb_monitoring_indicators)[!reaped@keep]
```

```{r Plot features onto PC space}
plot(threshed)
```

```{r Optimal-num-groups}
reaped@nGroups
```

```{r get-pca}
pca_df <- reaped@spca@scores

pca_loadings <- reaped@loadings %>% 
  as_tibble(rownames = "variable")

no_pca <- reaped@pcdim
```

```{r cluster-on-pca-space}
clust <- NbClust(pca_df[,1:no_pca], min.nc = 1, method="ward.D2", index="trcovw")
```

```{r vis-clust, fig.width = 10, fig.height = 10, dpi = 330}
tb_reclust <- tb_monitoring_indicators %>% 
  mutate(nb_cluster = clust$Best.partition) %>% 
  mutate(cluster = as.numeric(cluster)) %>% 
  mutate(recluster = case_when(nb_cluster == cluster ~ as.character(cluster),
                               nb_cluster != cluster ~ paste0(cluster, "~", nb_cluster)))
```

```{r compare-raw-performance}
tb_reclust %>% 
  count(recluster) %>% 
  mutate(prop = n / sum(n)) %>% 
  ggplot(aes(x = recluster, y = prop, fill = recluster)) + 
  geom_bar(stat = "identity") +
  theme_minimal() +
  scale_y_continuous(labels = percent, breaks = seq(0, 0.8, 0.05), 
                     minor_breaks = NULL) +
  scale_fill_viridis(option = "viridis", 
                     discrete = TRUE,
                       end = 0.9) +
  theme(legend.position = "none")
```

```{r summary-plot, fig.height = 8, fig.width = 12, dpi = 330}
sum_tb_df <- tb_reclust %>% 
  gather(., key = "Variable", value = "value", 
               -AreaName, -recluster, -cluster, -nb_cluster) %>% 
  rename(Cluster = recluster) 

plot_cluster_diff <- sum_tb_df %>% 
  ggplot(aes(x = Cluster, y = value, col = Cluster, fill = Cluster)) +
  geom_violin(draw_quantiles = c(0.025, 0.5, 0.975), alpha = 0.1, scale = "width") +
  geom_jitter(position = position_jitterdodge(), alpha = 0.5) +
  coord_flip() +
  theme_minimal() +
  theme(legend.position = "bottom") +
  scale_y_continuous(minor_breaks = NULL) +
  scale_colour_viridis(option = "viridis", discrete = TRUE, end = 0.9) +
  scale_fill_viridis(option = "viridis", discrete = TRUE, end = 0.9) +
  facet_wrap(~Variable, scales = "free") +
  labs( 
    title = "Tuberculosis in England; Summarised by Cluster",
    subtitle = "Violin plots are scaled by width, with the 2.5%, 50% and 97.5% quantiles shown.",
    x = "Variable",
    y = "Incidence rate (per 100,000) for rec_int_rate, otherwise proportion (0-100%)",
    caption = "@seabbs Source: Public Health England (fingertipsR)")

plot_cluster_diff
```

```{r get-county-codes}
county_codes <- fingertips_data(IndicatorID = 91361) %>% 
  select(AreaCode, AreaName, AreaType) %>% 
  filter(AreaType %in% "County & UA") %>% 
  unique
```

```{r map-fn, dpi = 330,  fig.height = 8, fig.width = 8, warning = FALSE}
## Make the plot into a function as ggplot2 object is very large and cause git issues (i.e therefore easier to remake the plot than it is to transfer between code chunks)
  ## Some issues here with extracting code from the sp file
## Solved using the folling maptools functions - improvements appreciated!
gpclibPermit()

england_counties <- shapefile("../../static/data/shapefiles/england-2011-ct-shape/england_ct_2011.shp") %>%
  fortify(region = "code") %>% 
  as_tibble

england_urban_areas <- shapefile("../../static/data/shapefiles/england-urb-2001-shape/england_urb_2001.shp") %>% 
  fortify(region = "name") %>% 
  as_tibble %>% 
  filter(id %in% c("Greater London Urban Area", 
                   "Greater Manchester Urban Area",
                   "Bristol Urban Area",
                   "West Midlands Urban Area",
                   "Milton Keynes Urban Area"))

## Make custom positions for urban area labels
urban_area_labels <- england_urban_areas %>%
  group_by(id) %>% 
  slice(100) %>% 
  ungroup() %>% 
  mutate(long = long - 200000,
         lat = lat + 20000)
  
  
tb_cluster_results <- tb_reclust

tb_cluster_results <- county_codes %>% 
  left_join(tb_cluster_results,
            by = "AreaName") %>% 
  left_join(england_counties, by = c("AreaCode" = "id"))

   tb_cluster_results %>% 
  rename(Cluster = recluster) %>% 
  drop_na(Cluster) %>% 
  dplyr::select(long, lat, Cluster, group) %>% 
  ggplot( 
                 aes(x = long, 
                     y = lat,
                     fill = Cluster)) +
    geom_polygon(data = england_urban_areas, 
                 aes(group = group, fill = NULL),
                 alpha = 0.4) +
    geom_path(data = tb_cluster_results, 
              aes(group = group, fill = NULL), 
              alpha = 0.4) +
    geom_polygon(data = tb_cluster_results, 
                 aes(group = group, fill = NULL),
                 alpha = 0.1) +
    geom_polygon(aes(group = group), alpha = 0.6) +
    geom_line(data = urban_area_labels %>% 
                bind_rows(urban_area_labels %>% 
                            mutate(long = long + 200000, 
                                   lat = lat - 20000)),
              aes(fill = NA, group = id), alpha = 0.8) + 
    geom_label(data = urban_area_labels,
              aes(label = id), fill = "grey") +
    scale_fill_viridis(option = "viridis", discrete = TRUE,
                       end = 0.9) +
    coord_equal() +
    theme_map() +
    theme(legend.position = "bottom") +
    labs(title = "Tuberculosis Monitoriing Indicators; Map of County Level Clusters in England",
         subtitle = "Using data from 2015 - only counties with incidence rates above 10 per 100,000 population and complete data are shown",
         caption = "Selected urban areas are shown (dark grey) and labelled.
@seabbs Source: Public Health England (fingertipsR)
Contains National Statistics data © Crown copyright and database right 2018. 
         Contains OS data © Crown copyright and database right 2018")
```